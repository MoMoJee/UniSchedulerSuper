# 流式状态恢复 - 关键问题修复说明

## 🐛 已修复的问题

### 问题 1: 在 Agent 回复出现之前刷新，保存不被触发

**原因分析**:
- 之前的逻辑是在收到 `stream_start` 事件时才保存流式状态
- 如果用户在发送消息后立即刷新，`stream_start` 事件还没到达，导致没有保存状态

**解决方案**:
✅ **在 `sendMessage()` 方法中，发送消息后立即保存初始流式状态**

```javascript
// core/static/js/agent-chat.js - sendMessage() 方法
async sendMessage() {
    // ... 前面的代码 ...
    
    // 标记为处理中
    this.isProcessing = true;
    this.updateSendButton();
    
    // 【关键】立即保存流式状态（即使还没开始接收内容）
    this.isStreamingActive = true;
    this.streamingContent = '';
    this.saveStreamingState();
    console.log('📤 消息已发送，初始化流式状态');
    
    // 发送到 WebSocket
    this.socket.send(JSON.stringify({
        type: 'message',
        content: fullMessage
    }));
}
```

**效果**:
- ✅ 用户发送消息后立即刷新 → 能够检测到流式状态
- ✅ 恢复后会看到"正在思考..."提示
- ✅ WebSocket 重连后继续接收内容

---

### 问题 2: LangGraph 节点流式导致的状态误判

**原因分析**:
1. **LangGraph 使用的是节点流式输出**，不是 token 流式：
   - 每次工具调用结果是一股一股输出的
   - 在等待 LLM 回复时，`is_processing` 可能为 `false`
   - 在工具调用之间的间隙，`is_processing` 也为 `false`

2. **旧的判断逻辑过于简单**：
   ```javascript
   if (data.is_processing === false) {
       // 错误地认为已完成
       forceEndStreamingWithSync();
   }
   ```

**解决方案**:

#### 方案 1: 前端通过 API 检查最后一条消息类型
```javascript
// 查询历史消息
const response = await fetch(`/api/agent/history/?session_id=${sessionId}`);
const data = await response.json();
const lastMsg = data.messages[data.messages.length - 1];

// 如果最后一条是完整的 assistant 消息（不是 tool），说明真的完成了
if (lastMsg.role === 'assistant' && lastMsg.content && !lastMsg.tool_calls) {
    // 真的完成了
    forceEndStreamingWithSync();
} else {
    // 还在处理中（可能在等待工具调用或 LLM 回复）
    console.log('后端可能还在处理');
}
```

#### 方案 2: 后端返回更详细的状态信息
```python
# agent_service/consumers.py
elif msg_type == "check_status":
    # 获取 LangGraph 的实际状态
    has_pending_messages = False
    last_message_role = None
    
    state = app.get_state(config)
    messages = state.values.get("messages", [])
    if messages:
        last_msg = messages[-1]
        last_message_role = getattr(last_msg, 'type', None)
        
        # 如果最后一条消息是工具消息或人类消息，说明还需要继续处理
        if last_message_role in ['tool', 'human']:
            has_pending_messages = True
    
    await self.send_json({
        "type": "status_response",
        "is_processing": self.is_processing,
        "has_pending_messages": has_pending_messages,
        "last_message_role": last_message_role
    })
```

#### 方案 3: 前端综合判断
```javascript
case 'status_response':
    console.log('📥 收到状态响应:', data);
    
    if (this.isStreamingActive) {
        if (data.has_pending_messages) {
            // 还有待处理的消息（例如工具调用结果），继续等待
            console.log('⏳ 检测到待处理消息，继续等待...');
        } else if (!data.is_processing && !data.has_pending_messages) {
            // 没有活跃任务，也没有待处理消息，应该是完成了
            console.log('✅ 确认后端已完成');
            // 给 1 秒延迟，让可能的 finished 消息先到达
            setTimeout(() => {
                if (this.isStreamingActive) {
                    this.forceEndStreamingWithSync();
                }
            }, 1000);
        }
    }
    break;
```

---

## 🔍 LangGraph 节点流式输出说明

### 当前实现
后端使用的是 **节点级别的流式输出**（`app.stream()`），而不是 token 级别：

```python
# agent_service/consumers.py
for output in app.stream(input_state, config):
    # output 是整个节点的输出
    # 不是逐个 token
```

### 输出特点
1. **一股一股的**：每次输出是一个完整的节点结果
   - Agent 的思考内容 → 一股
   - 工具调用请求 → 一股
   - 工具调用结果 → 一股
   - Agent 的最终回复 → 一股

2. **间隙期间**：
   - 在工具调用之间，可能有等待时间
   - 在等待 LLM 回复时，没有输出
   - 这些时候 `is_processing` 可能为 `false`

### 为什么不能只看 `is_processing`
```
时间轴示例：

t0: 用户发送消息
    is_processing = True
    
t1: Agent 开始思考（调用 LLM）
    is_processing = False (等待 LLM 回复)
    
t2: Agent 返回工具调用请求
    is_processing = True
    输出：tool_call
    
t3: 执行工具
    is_processing = True
    
t4: 工具结果返回，再次调用 Agent
    is_processing = False (等待 LLM 回复)  ← 这里刷新会误判！
    
t5: Agent 返回第二次工具调用
    is_processing = True
    输出：tool_call
    
t6: 最终回复
    is_processing = True
    输出：assistant message
    
t7: 完成
    is_processing = False
    last_message_role = 'assistant'  ← 真的完成了
```

---

## 📊 新的判断逻辑

### 三层保护机制

#### 1. API 检查（最准确）
```javascript
// 通过历史消息 API 检查最后一条消息
const lastMsg = messages[messages.length - 1];

if (lastMsg.role === 'assistant' && lastMsg.content && !lastMsg.tool_calls) {
    // 最后一条是完整的 assistant 回复 → 真的完成了
    return true;
}
```

#### 2. WebSocket 状态检查
```javascript
if (data.has_pending_messages) {
    // 还有 tool 或 human 消息待处理 → 未完成
    return false;
}

if (!data.is_processing && !data.has_pending_messages) {
    // 没有活跃任务，也没有待处理消息 → 可能完成了
    return true;
}
```

#### 3. 超时保护
```javascript
// 10 秒后仍未收到新消息 → 强制同步
setTimeout(() => {
    if (this.isStreamingActive) {
        this.forceEndStreamingWithSync();
    }
}, 10000);
```

---

## 🎯 测试场景

### 场景 1: 发送消息后立即刷新（问题1）
```
1. 输入消息："帮我查询今天的日程"
2. 点击发送
3. 立即按 F5（不等任何输出）
4. 观察控制台：
   ✅ 应该看到：📤 消息已发送，初始化流式状态
   ✅ 应该看到：💾 保存流式状态: {contentLength: 0, ...}
   ✅ 刷新后能够恢复状态
```

### 场景 2: 在工具调用间隙刷新（问题2）
```
1. 发送需要多次工具调用的消息
2. 等待第一个工具结果显示
3. 在第二个工具调用时刷新
4. 观察控制台：
   ✅ 不应该看到：⚠️ 后端已完成但前端仍在流式状态
   ✅ 应该看到：⏳ 检测到待处理消息，继续等待
   ✅ 继续接收后续输出
```

### 场景 3: 真正完成后刷新
```
1. 发送消息
2. 等待完整回复结束
3. 刷新页面
4. 观察：
   ✅ 短暂恢复提示
   ✅ 1-2 秒后自动同步
   ✅ 显示完整内容
```

---

## 📝 日志示例

### 正常场景（发送后立即刷新）
```
[发送消息]
📤 消息已发送，初始化流式状态
💾 保存流式状态: {key: "...", isActive: true, contentLength: 0}

[刷新页面]
🔍 检查流式状态: {hasState: true, ...}
📦 读取到状态: {isActive: true, contentLength: 0, ...}
✅ 流式状态恢复完成
🔍 检查后端流式状态...
📥 收到状态响应: {is_processing: false, has_pending_messages: true}
⏳ 检测到待处理消息，继续等待...

[继续接收]
💾 保存流式状态: {contentLength: 50}
💾 保存流式状态: {contentLength: 100}
...
```

### 工具调用间隙刷新
```
[第一个工具调用完成]
💾 保存流式状态: {contentLength: 200}

[刷新页面]
🔍 检查流式状态: {hasState: true}
✅ 流式状态恢复完成: {contentLength: 200}
🔍 检查后端流式状态...

[API 检查]
⏳ 后端可能还在处理（最后消息不是完整回复）{
    role: 'tool',
    hasContent: true,
    hasToolCalls: false
}

[WebSocket 检查]
📥 收到状态响应: {
    is_processing: false,
    has_pending_messages: true,  ← 检测到待处理的 tool 消息
    last_message_role: 'tool'
}
⏳ 检测到待处理消息，继续等待...

[继续接收]
💾 保存流式状态: {contentLength: 250}
...
```

---

## 🔧 代码修改总结

### 前端修改
1. **sendMessage()** - 发送时立即保存流式状态
2. **checkStreamingStatusAfterRestore()** - 通过 API 检查最后消息类型
3. **status_response 处理** - 综合判断是否真的完成

### 后端修改
1. **check_status 处理** - 返回更详细的状态信息
   - `has_pending_messages`: 是否有待处理消息
   - `last_message_role`: 最后一条消息的角色

---

**更新时间**: 2026-01-19  
**版本**: v3.0  
**状态**: 已完全修复
