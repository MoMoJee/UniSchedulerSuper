### **1. 核心设计原则**

```
┌─────────────────────────────────────────────────────────┐
│  Quick Action Agent 执行模式                             │
│                                                          │
│  1. 接收用户输入                                         │
│  2. Agent 自主规划和执行（可多次调用工具）               │
│  3. 强制要求：必须返回确定性结果                         │
│     - 成功：操作已执行                                   │
│     - 失败但可恢复：返回建议供用户重新请求               │
│     - 失败不可恢复：返回错误原因                         │
│  4. 禁止：向用户提问或等待用户响应                       │
└─────────────────────────────────────────────────────────┘
```

---

## **2. 数据模型**

```python
# agent_service/models.py

class QuickActionTask(models.Model):
    """快速操作任务"""
    task_id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    
    # 输入
    input_text = models.TextField(verbose_name="用户输入")
    
    # 状态：pending, processing, success, failed, timeout
    status = models.CharField(max_length=20, default='pending', db_index=True)
    
    # 结果类型：action_completed, need_clarification, error
    result_type = models.CharField(max_length=30, blank=True)
    
    # 结果（JSON）
    result = models.JSONField(null=True, blank=True)
    
    # 执行追踪
    tool_calls = models.JSONField(default=list)  # 工具调用记录
    agent_reasoning = models.TextField(blank=True)  # Agent 推理过程
    
    # 时间
    created_at = models.DateTimeField(auto_now_add=True)
    started_at = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
    # Token 消耗（按用户配置的模型计费）
    input_tokens = models.IntegerField(default=0)
    output_tokens = models.IntegerField(default=0)
    total_cost = models.FloatField(default=0.0)  # CNY
    model_used = models.CharField(max_length=100, blank=True)
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', '-created_at']),
            models.Index(fields=['status', 'created_at']),
        ]
        
    def __str__(self):
        return f"{self.user.username} - {self.input_text[:30]} - {self.status}"
```

---

## **3. Quick Action Agent 实现**

基于现有 LangGraph 架构，创建专门的 Quick Action Graph：

```python
# agent_service/quick_action_agent.py

from langgraph.graph import StateGraph, END
from langgraph.prebuilt import ToolNode
from typing import TypedDict, Annotated, List
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage
import operator
from datetime import datetime

from agent_service.agent_graph import get_user_llm, PLANNER_TOOLS
from agent_service.context_optimizer import update_token_usage, get_current_model_config
from logger import logger

class QuickActionState(TypedDict):
    """Quick Action 状态"""
    messages: Annotated[List, operator.add]
    user: object  # Django User
    task_id: str
    input_text: str
    
    # 执行追踪
    iteration: int  # 迭代次数
    tool_calls_log: List[dict]  # 工具调用日志
    
    # 最终结果
    final_result: dict
    tokens_used: dict  # {input: x, output: y, model: 'xxx'}

# System Prompt（核心）
QUICK_ACTION_SYSTEM_PROMPT = """你是一个快速操作执行器，负责根据用户的一句话指令立即执行日程管理操作。

## 核心规则
1. **禁止询问用户**：无论任何情况，你都不能向用户提问或等待用户回复
2. **必须给出确定性结果**：只能返回以下三种结果之一
3. **单次对话执行**：你只有这一次机会完成任务，不会有后续对话
4. **可多次调用工具**：你可以多次使用工具来完成任务，但必须主动决策

## 三种允许的结果

### 结果1：操作成功 ✅
当你成功执行了操作（创建、修改、删除、完成待办等），返回：
- 明确说明执行了什么操作
- 提供操作的详细信息
- 使用友好的自然语言描述

示例：
"✅ 已将「团队会议」的时间从 2月8日 14:00-15:00 修改为 20:00-21:00"
"✅ 已创建新日程：2月10日 09:00-10:00「项目评审」"
"✅ 已完成待办：提交月度报告"

### 结果2：需要明确信息 ⚠️（严格限制使用）
**仅当满足以下所有条件时才能使用**：
1. 用户提供的信息确实不足以执行操作
2. 你已经尝试通过工具搜索但找到了多个完全无法区分的匹配项
3. 缺失的信息是用户必须明确指定的（如"哪一个会议"）

返回格式：
- 清楚说明为什么无法执行
- 列出找到的所有选项（最多5个）
- 提示用户如何补充信息

示例：
"⚠️ 找到 3 个2月8日的会议，无法确定要修改哪一个：
1. 09:00-10:00「晨会」
2. 14:00-15:00「团队会议」  
3. 16:00-17:00「项目评审」
请在下次请求中明确指定会议名称，如'将团队会议改到晚上8点'"

**禁止滥用**：
- ❌ 不能因为"可能有风险"就返回建议
- ❌ 不能因为"想确认一下"就返回建议
- ❌ 如果只找到1个匹配，必须直接执行，不能询问
- ❌ 如果可以通过上下文推断，必须推断而不是询问

### 结果3：操作失败 ❌
当操作无法执行且无法恢复时：
- 说明失败原因
- 不提供建议（因为无法恢复）

示例：
"❌ 未找到2月8日的任何会议"
"❌ 操作失败：日程已被删除"
"❌ 缺少必要信息：未指定日程时间"

## 可用工具
- search_items: 搜索日程/待办/提醒
- create_item: 创建新项目
- update_item: 更新已有项目
- delete_item: 删除项目
- get_event_groups: 获取日程组列表
- get_share_groups: 获取分享组列表
- complete_todo: 快捷完成待办

## 典型执行流程

### 场景A：修改日程
用户输入："2月8日的会议改到晚上8点"

1. 调用 search_items(item_type="event", time_range="2026-02-08")
2. 检查结果：
   - 如果找到1个会议 → 直接调用 update_item 修改
   - 如果找到多个会议 → 返回结果2（需要明确）
   - 如果没找到 → 返回结果3（失败）

### 场景B：创建日程
用户输入："明天下午3点开会，讨论项目进度"

1. 解析信息：时间=明天15:00，标题=讨论项目进度
2. 调用 create_item(item_type="event", title="讨论项目进度", start="2026-02-05 15:00", ...)
3. 返回结果1（成功）

### 场景C：完成待办
用户输入："完成报告提交"

1. 调用 search_items(item_type="todo", keyword="报告提交")
2. 如果找到1个 → 调用 complete_todo
3. 返回结果1（成功）

## 智能推断规则
1. **时间推断**：
   - "明天" = 当前日期+1天
   - "下周一" = 计算下周一的日期
   - "晚上8点" = 20:00
   
2. **持续时间推断**：
   - 会议默认1小时
   - 如果说"2小时会议"，则设置相应时长
   
3. **重复规则推断**：
   - "每周" → 按周重复
   - "每天" → 按天重复

## 当前时间
{current_time}

## 执行要求
- 立即分析用户输入并开始执行
- 需要信息时先用工具搜索，不要假设
- 执行后立即返回明确结果
- 保持简洁但完整的反馈
"""

def build_system_message(current_time: str) -> SystemMessage:
    """构建系统消息"""
    return SystemMessage(content=QUICK_ACTION_SYSTEM_PROMPT.format(
        current_time=current_time
    ))

# Agent 节点
def agent_node(state: QuickActionState):
    """Agent 决策节点"""
    user = state['user']
    messages = state['messages']
    
    # 获取用户配置的 LLM
    llm = get_user_llm(user)
    
    # 绑定工具
    tools = list(PLANNER_TOOLS.values())
    llm_with_tools = llm.bind_tools(tools)
    
    # 调用 LLM
    response = llm_with_tools.invoke(messages)
    
    # 记录 Token 使用
    input_tokens = 0
    output_tokens = 0
    if hasattr(response, 'usage_metadata'):
        usage = response.usage_metadata
        if isinstance(usage, dict):
            input_tokens = usage.get('input_tokens', 0) or usage.get('prompt_tokens', 0)
            output_tokens = usage.get('output_tokens', 0) or usage.get('completion_tokens', 0)
        else:
            input_tokens = getattr(usage, 'input_tokens', 0) or getattr(usage, 'prompt_tokens', 0)
            output_tokens = getattr(usage, 'output_tokens', 0) or getattr(usage, 'completion_tokens', 0)
    
    # 更新状态
    return {
        "messages": [response],
        "iteration": state['iteration'] + 1,
        "tokens_used": {
            "input": state.get('tokens_used', {}).get('input', 0) + input_tokens,
            "output": state.get('tokens_used', {}).get('output', 0) + output_tokens
        }
    }

def tool_node_wrapper(state: QuickActionState):
    """工具执行节点（包装现有工具）"""
    from langchain_core.runnables import RunnableConfig
    
    user = state['user']
    messages = state['messages']
    last_message = messages[-1]
    
    # 构建 config
    config = RunnableConfig(
        configurable={
            "user": user,
            "thread_id": state['task_id'],
            "session_id": state['task_id']
        }
    )
    
    # 执行工具调用
    tool_results = []
    for tool_call in last_message.tool_calls:
        tool_name = tool_call['name']
        tool_args = tool_call['args']
        
        # 记录工具调用
        log_entry = {
            "tool": tool_name,
            "args": tool_args,
            "timestamp": datetime.now().isoformat()
        }
        
        try:
            # 执行工具
            tool = PLANNER_TOOLS[tool_name]
            result = tool.invoke(tool_args, config=config)
            log_entry["result"] = str(result)[:500]  # 截断长结果
            log_entry["status"] = "success"
        except Exception as e:
            logger.error(f"Tool {tool_name} failed: {e}")
            result = f"工具执行失败: {str(e)}"
            log_entry["result"] = result
            log_entry["status"] = "error"
        
        tool_results.append({
            "role": "tool",
            "content": result,
            "tool_call_id": tool_call['id']
        })
        
        state['tool_calls_log'].append(log_entry)
    
    return {"messages": tool_results}

# 路由逻辑
def should_continue(state: QuickActionState) -> str:
    """判断是否继续执行"""
    messages = state['messages']
    last_message = messages[-1]
    iteration = state.get('iteration', 0)
    
    # 最多执行 10 轮（防止无限循环）
    if iteration >= 10:
        logger.warning(f"Quick action task {state['task_id']} reached max iterations")
        return "format_result"
    
    # 如果有工具调用，继续执行
    if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
        return "tools"
    
    # 否则结束
    return "format_result"

def format_result_node(state: QuickActionState):
    """格式化最终结果"""
    messages = state['messages']
    last_message = messages[-1]
    
    # 提取 AI 的最终回复
    if hasattr(last_message, 'content'):
        content = last_message.content
    else:
        content = str(last_message)
    
    # 分析结果类型
    result_type = "action_completed"
    if "⚠️" in content or "需要明确" in content or "无法确定" in content:
        result_type = "need_clarification"
    elif "❌" in content or "失败" in content or "错误" in content:
        result_type = "error"
    
    return {
        "final_result": {
            "type": result_type,
            "message": content,
            "tool_calls": state.get('tool_calls_log', [])
        }
    }

# 构建 Graph
def create_quick_action_graph():
    """创建 Quick Action Graph"""
    workflow = StateGraph(QuickActionState)
    
    # 添加节点
    workflow.add_node("agent", agent_node)
    workflow.add_node("tools", tool_node_wrapper)
    workflow.add_node("format_result", format_result_node)
    
    # 设置入口
    workflow.set_entry_point("agent")
    
    # 添加条件边
    workflow.add_conditional_edges(
        "agent",
        should_continue,
        {
            "tools": "tools",
            "format_result": "format_result"
        }
    )
    
    # 工具执行后回到 agent
    workflow.add_edge("tools", "agent")
    
    # 结束
    workflow.add_edge("format_result", END)
    
    return workflow.compile()

# 全局实例
quick_action_graph = create_quick_action_graph()
```

---

## **4. API 实现**

```python
# agent_service/views_quick_action.py

from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from django.utils import timezone
import threading
import uuid
from datetime import datetime, timedelta

from agent_service.models import QuickActionTask
from agent_service.quick_action_agent import quick_action_graph, build_system_message
from agent_service.context_optimizer import update_token_usage, get_current_model_config
from langchain_core.messages import HumanMessage
from logger import logger

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_quick_action(request):
    """
    创建快速操作任务
    
    POST /api/quick-action/
    Body: {"text": "2月8日的会议改到晚上8点", "timeout": 30}
    """
    text = request.data.get('text', '').strip()
    timeout = request.data.get('timeout', 30)
    
    if not text:
        return Response(
            {"error": "输入文本不能为空"},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    # 创建任务
    task = QuickActionTask.objects.create(
        user=request.user,
        input_text=text
    )
    
    # 异步执行
    thread = threading.Thread(
        target=execute_quick_action,
        args=(task.task_id, request.user, text, timeout)
    )
    thread.daemon = True
    thread.start()
    
    return Response({
        "task_id": str(task.task_id),
        "status": "pending",
        "status_url": f"/api/quick-action/{task.task_id}/",
        "created_at": task.created_at.isoformat()
    }, status=status.HTTP_201_CREATED)

def execute_quick_action(task_id, user, text, timeout):
    """执行快速操作（后台线程）"""
    try:
        task = QuickActionTask.objects.get(task_id=task_id)
        task.status = 'processing'
        task.started_at = timezone.now()
        task.save()
        
        # 构建初始消息
        current_time = datetime.now().strftime('%Y-%m-%d %H:%M')
        system_msg = build_system_message(current_time)
        user_msg = HumanMessage(content=text)
        
        # 构建初始状态
        initial_state = {
            "messages": [system_msg, user_msg],
            "user": user,
            "task_id": str(task_id),
            "input_text": text,
            "iteration": 0,
            "tool_calls_log": [],
            "tokens_used": {"input": 0, "output": 0}
        }
        
        # 执行 Graph
        final_state = quick_action_graph.invoke(
            initial_state,
            config={"recursion_limit": 15}
        )
        
        # 获取用户模型信息
        model_id, _ = get_current_model_config(user)
        
        # 更新 Token 统计
        tokens = final_state.get('tokens_used', {})
        input_tokens = tokens.get('input', 0)
        output_tokens = tokens.get('output', 0)
        
        if input_tokens > 0 or output_tokens > 0:
            update_token_usage(user, input_tokens, output_tokens, model_id)
        
        # 保存结果
        result = final_state.get('final_result', {})
        task.status = 'success' if result.get('type') == 'action_completed' else 'failed'
        task.result_type = result.get('type')
        task.result = result
        task.tool_calls = final_state.get('tool_calls_log', [])
        task.input_tokens = input_tokens
        task.output_tokens = output_tokens
        task.model_used = model_id
        task.completed_at = timezone.now()
        task.save()
        
        logger.info(f"Quick action {task_id} completed: {task.status}")
        
    except Exception as e:
        logger.exception(f"Quick action {task_id} failed: {e}")
        task.status = 'failed'
        task.result = {
            "type": "error",
            "message": f"执行出错: {str(e)}"
        }
        task.completed_at = timezone.now()
        task.save()

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_quick_action_status(request, task_id):
    """
    查询任务状态
    
    GET /api/quick-action/<task_id>/?wait=true
    """
    try:
        task = QuickActionTask.objects.get(task_id=task_id, user=request.user)
    except QuickActionTask.DoesNotExist:
        return Response(
            {"error": "任务不存在"},
            status=status.HTTP_404_NOT_FOUND
        )
    
    # 长轮询支持
    wait = request.query_params.get('wait', 'false').lower() == 'true'
    if wait and task.status in ['pending', 'processing']:
        # 等待最多 30 秒
        import time
        for _ in range(60):  # 30秒，每0.5秒检查一次
            time.sleep(0.5)
            task.refresh_from_db()
            if task.status not in ['pending', 'processing']:
                break
    
    response_data = {
        "task_id": str(task.task_id),
        "status": task.status,
        "input_text": task.input_text,
        "created_at": task.created_at.isoformat(),
    }
    
    if task.started_at:
        response_data["started_at"] = task.started_at.isoformat()
    
    if task.completed_at:
        response_data["completed_at"] = task.completed_at.isoformat()
        response_data["duration"] = (task.completed_at - task.created_at).total_seconds()
    
    if task.status in ['success', 'failed']:
        response_data["result"] = task.result
        response_data["tokens_used"] = {
            "input": task.input_tokens,
            "output": task.output_tokens,
            "total": task.input_tokens + task.output_tokens
        }
        response_data["model_used"] = task.model_used
    
    return Response(response_data)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def list_quick_actions(request):
    """
    列出用户的快速操作历史
    
    GET /api/quick-action/?limit=20
    """
    limit = int(request.query_params.get('limit', 20))
    tasks = QuickActionTask.objects.filter(user=request.user)[:limit]
    
    data = [{
        "task_id": str(task.task_id),
        "input_text": task.input_text,
        "status": task.status,
        "result_type": task.result_type,
        "created_at": task.created_at.isoformat(),
        "completed_at": task.completed_at.isoformat() if task.completed_at else None
    } for task in tasks]
    
    return Response({"tasks": data, "count": len(data)})
```

---

## **5. URL 配置**

```python
# agent_service/urls.py

from django.urls import path
from agent_service.views_quick_action import (
    create_quick_action,
    get_quick_action_status,
    list_quick_actions
)

urlpatterns = [
    # ... 现有路由 ...
    
    # Quick Action API
    path('quick-action/', create_quick_action, name='create_quick_action'),
    path('quick-action/<uuid:task_id>/', get_quick_action_status, name='get_quick_action_status'),
    path('quick-action/list/', list_quick_actions, name='list_quick_actions'),
]
```

---

## **6. 关键特性总结**

### ✅ 满足要求1：可多次工具调用，不与用户对话
- Agent 使用 ReAct 模式，可以多次调用工具
- System Prompt 明确禁止询问用户
- 路由逻辑限制最多 10 轮迭代

### ✅ 满足要求2：精巧的提示词控制建议滥用
- 明确定义三种结果类型
- 严格限制"需要明确信息"的使用条件：
  1. 信息确实不足
  2. 已搜索但找到多个无法区分的匹配
  3. 缺失信息必须由用户指定
- 明确禁止的行为（❌ 示例）

### ✅ 满足要求3：使用现有计费框架
- 使用 `get_user_llm(user)` 获取用户配置的模型
- 使用 `get_current_model_config(user)` 获取模型ID
- 使用 `update_token_usage(user, input_tokens, output_tokens, model_id)` 自动计费
- Token 统计和成本计算完全复用现有逻辑

---

## **7. TODO 清单**

### Phase 1：核心功能（必须完成）

- [x] **1.1 创建 QuickActionTask 模型** ✅
  - 在 `agent_service/models.py` 中添加模型定义
  - 待执行：数据库迁移 (`python manage.py makemigrations && python manage.py migrate`)

- [x] **1.2 创建 Quick Action Agent** ✅
  - 创建 `agent_service/quick_action_agent.py`
  - 实现 `QuickActionState` 状态定义
  - 实现 `build_system_message()` 系统提示词
  - 实现 `agent_node()` Agent 决策节点
  - 实现 `tool_node_wrapper()` 工具执行节点
  - 实现 `should_continue()` 路由逻辑
  - 实现 `format_result_node()` 结果格式化节点
  - 构建并编译 LangGraph

- [x] **1.3 创建 API 视图** ✅
  - 创建 `agent_service/views_quick_action.py`
  - 实现 `create_quick_action()` 创建任务接口（支持同步/异步模式）
  - 实现 `_execute_async()` 后台执行函数
  - 实现 `get_quick_action_status()` 状态查询接口（支持长轮询）
  - 实现 `list_quick_actions()` 历史记录接口
  - 实现 `cancel_quick_action()` 取消任务接口

- [x] **1.4 配置 URL 路由** ✅
  - 在 `agent_service/urls.py` 中添加路由

- [ ] **1.5 基础测试**
  - 测试创建任务 API
  - 测试状态查询 API
  - 测试完整执行流程

### Phase 2：优化和完善

- [ ] **2.1 超时处理**
  - 实现任务超时自动标记
  - 添加后台任务清理机制

- [ ] **2.2 错误处理增强**
  - 完善各种异常情况的处理
  - 添加更详细的错误日志

- [ ] **2.3 长轮询优化**
  - 使用异步视图优化长轮询性能
  - 考虑 SSE (Server-Sent Events) 替代方案

- [ ] **2.4 速率限制**
  - 限制每用户并发任务数
  - 添加请求频率限制

### Phase 3：高级功能（可选）

- [ ] **3.1 WebSocket 支持**
  - 实时推送任务状态更新

- [ ] **3.2 批量操作**
  - 支持一次请求执行多个操作

- [ ] **3.3 操作历史和统计**
  - 统计成功率、平均执行时间等

---
