# 流式状态恢复 - 超时机制优化

## 🐛 问题描述

### 场景
用户在工具调用的间隙刷新页面，触发了 10 秒超时保护，导致流式状态被强制结束。

### 日志示例
```
✅ 流式状态恢复完成 {contentLength: 42}
🔍 检查后端流式状态...
⏰ 流式恢复超时，强制结束  ← 问题！
🔄 强制结束流式状态，同步最新消息...
```

### 问题分析

1. **工具调用间隔时间长**
   - LangGraph 使用节点级流式输出
   - Agent 调用工具 → 等待工具执行 → 等待 LLM 回复 → 下一次输出
   - 每个间隔可能需要 10-30 秒甚至更长

2. **旧的超时机制过于简单**
   ```javascript
   // 旧代码
   setTimeout(() => {
       console.log('⏰ 流式恢复超时，强制结束');
       this.forceEndStreamingWithSync();  // 无条件结束！
   }, 10000); // 只有10秒
   ```

3. **导致的问题**
   - ❌ 在工具调用间隙刷新 → 10 秒后被误判为超时
   - ❌ 实际上后端还在处理，不应该结束
   - ❌ 用户看到"已同步"，但实际回复还没完成

---

## ✅ 解决方案

### 改进的超时机制

#### 1. 增加超时时间
从 **10 秒** 改为 **30 秒**，给工具调用留出足够时间

#### 2. 超时时先检查状态
超时触发时不直接结束，而是：
1. 查询历史消息 API
2. 检查最后一条消息的类型
3. 只有确认完成才结束
4. 否则延长超时继续等待

#### 3. 二次超时保护
如果第一次超时检查后仍在处理，再等待 30 秒后才强制同步

---

## 📝 新的代码实现

```javascript
// 设置 30 秒超时
this.streamingRestoreTimeout = setTimeout(async () => {
    if (this.isStreamingActive && document.getElementById('streamingMessage')) {
        console.log('⏰ 流式恢复超时（30秒），检查状态...');
        
        // 【关键】超时时先检查状态
        try {
            const response = await fetch(`/api/agent/history/?session_id=${sessionId}`, {
                headers: {'X-CSRFToken': this.csrfToken}
            });
            
            if (response.ok) {
                const data = await response.json();
                const messages = data.messages || [];
                
                if (messages.length > 0) {
                    const lastMsg = messages[messages.length - 1];
                    
                    // 【关键】只有最后一条是完整的 assistant 消息，才结束
                    if (lastMsg.role === 'assistant' && lastMsg.content && !lastMsg.tool_calls) {
                        console.log('✅ 确认后端已完成，执行强制同步');
                        this.forceEndStreamingWithSync();
                    } else {
                        // 【关键】后端还在处理，继续等待
                        console.log('⏳ 后端仍在处理中，继续等待', {
                            lastRole: lastMsg.role,
                            hasToolCalls: !!lastMsg.tool_calls
                        });
                        
                        // 【关键】延长超时时间，再等待 30 秒
                        this.streamingRestoreTimeout = setTimeout(() => {
                            if (this.isStreamingActive) {
                                console.log('⏰ 二次超时，强制同步');
                                this.forceEndStreamingWithSync();
                            }
                        }, 30000); // 再等 30 秒
                    }
                }
            } else {
                // API 失败，保守起见不结束
                console.warn('⚠️ 状态检查失败，继续等待');
            }
        } catch (error) {
            console.error('超时检查失败:', error);
            // 出错时不结束，让用户手动刷新
        }
    }
}, 30000); // 首次超时 30 秒
```

---

## 📊 工作流程对比

### 旧的超时机制 ❌
```
刷新页面
  ↓
恢复流式状态
  ↓
设置 10 秒超时
  ↓
10 秒后...
  ↓
⏰ 超时触发
  ↓
❌ 直接强制结束（不管后端状态）
  ↓
🔄 重新加载历史消息
```

**问题**：在工具调用间隙（可能 15-30 秒），会被误判为超时。

---

### 新的超时机制 ✅
```
刷新页面
  ↓
恢复流式状态
  ↓
设置 30 秒超时
  ↓
30 秒后...
  ↓
⏰ 超时触发
  ↓
🔍 检查后端状态（查询历史消息 API）
  ↓
  ├─ 最后消息是 assistant（完整回复）
  │   ↓
  │   ✅ 确认完成
  │   ↓
  │   🔄 强制同步
  │
  └─ 最后消息是 tool 或有 tool_calls
      ↓
      ⏳ 后端还在处理
      ↓
      延长 30 秒继续等待
      ↓
      60 秒后（二次超时）
      ↓
      ⏰ 二次超时触发
      ↓
      🔄 强制同步（最后的保险）
```

**优势**：
- ✅ 首次超时 30 秒，给工具调用足够时间
- ✅ 超时时检查状态，不盲目结束
- ✅ 如果还在处理，再等 30 秒
- ✅ 最多等待 60 秒后才强制同步

---

## 🎯 测试场景

### 场景 1: 在工具调用间隙刷新（15秒间隔）

**操作**:
1. 发送需要多次工具调用的消息
2. 等待第一个工具结果显示
3. 立即刷新（此时第二个工具正在执行，可能需要 15 秒）

**预期结果**:
```
✅ 流式状态恢复完成
🔍 检查后端流式状态...
⏳ 后端可能还在处理（最后消息不是完整回复）
📥 收到状态响应: {has_pending_messages: true}
⏳ 检测到待处理消息，继续等待...
（15秒后工具完成，继续接收）
💾 保存流式状态: {contentLength: 100}
（正常完成）
```

**不会触发超时**，因为 15 秒 < 30 秒。

---

### 场景 2: 在工具调用间隙刷新（35秒间隔）

**操作**:
1. 发送需要长时间工具调用的消息
2. 刷新（工具调用需要 35 秒）

**预期结果**:
```
✅ 流式状态恢复完成
🔍 检查后端流式状态...
（30秒后）
⏰ 流式恢复超时（30秒），检查状态...
⏳ 后端仍在处理中，继续等待 {lastRole: 'tool'}
（再等 30 秒）
（5秒后工具完成，继续接收）
💾 保存流式状态: {contentLength: 150}
（正常完成）
```

**虽然触发首次超时**，但检查后发现还在处理，延长等待时间。

---

### 场景 3: 回复真的完成了（刷新时已完成）

**操作**:
1. 等待回复完全结束
2. 刷新页面

**预期结果**:
```
✅ 流式状态恢复完成
🔍 检查后端流式状态...
✅ 确认后端已完成（最后消息是完整的 assistant 回复）
🔄 执行强制同步
（1秒后）
✅ 流式状态已强制结束并同步
```

**立即同步**，因为 API 检查确认了完成。

---

### 场景 4: 极端情况（工具调用超过 60 秒）

**操作**:
1. 发送需要非常长时间工具调用的消息
2. 刷新（工具调用需要 70 秒）

**预期结果**:
```
✅ 流式状态恢复完成
（30秒后）
⏰ 流式恢复超时（30秒），检查状态...
⏳ 后端仍在处理中，继续等待
（再30秒，共60秒后）
⏰ 二次超时，强制同步
🔄 强制结束流式状态，同步最新消息...
```

**60 秒后强制同步**，这是最后的保险机制。

---

## 📋 日志说明

### 正常情况（工具调用在 30 秒内完成）
```
✅ 流式状态恢复完成
🔍 检查后端流式状态...
⏳ 后端可能还在处理（最后消息不是完整回复）
📥 收到状态响应: {has_pending_messages: true}
⏳ 检测到待处理消息，继续等待...
💾 保存流式状态: {contentLength: 100}
✅ 正常完成
```

### 首次超时但还在处理
```
✅ 流式状态恢复完成
（30秒后）
⏰ 流式恢复超时（30秒），检查状态...
⏳ 后端仍在处理中，继续等待 {
    lastRole: 'tool',
    hasToolCalls: false
}
（继续等待...）
💾 保存流式状态: {contentLength: 150}
✅ 正常完成
```

### 超时检查确认完成
```
✅ 流式状态恢复完成
（30秒后）
⏰ 流式恢复超时（30秒），检查状态...
✅ 确认后端已完成，执行强制同步
🔄 强制结束流式状态，同步最新消息...
✅ 流式状态已强制结束并同步
```

### 二次超时（极端情况）
```
✅ 流式状态恢复完成
（30秒后）
⏰ 流式恢复超时（30秒），检查状态...
⏳ 后端仍在处理中，继续等待
（再30秒，共60秒后）
⏰ 二次超时，强制同步
🔄 强制结束流式状态，同步最新消息...
```

---

## 🔧 关键改进点

### 1. 超时时间增加
- **旧**: 10 秒
- **新**: 30 秒（首次）+ 30 秒（二次）= 最多 60 秒

### 2. 状态检查机制
- **旧**: 超时就结束，不检查状态
- **新**: 超时时先检查，只有确认完成才结束

### 3. 二次超时保护
- **旧**: 无
- **新**: 如果首次超时检查发现还在处理，再给 30 秒

### 4. 错误处理
- **旧**: 无
- **新**: 如果 API 失败，保守起见不结束

---

## 💡 为什么需要超时机制

虽然有状态检查，但超时机制仍然必要：

1. **防止卡死**: 如果 WebSocket 断开且无法重连，需要超时来救场
2. **用户体验**: 给用户一个明确的最长等待时间（60 秒）
3. **边界情况**: 处理各种网络异常、后端异常等情况

但超时机制必须**智能化**：
- ✅ 时间要足够长（30 秒）
- ✅ 触发时要检查状态
- ✅ 给第二次机会（延长等待）

---

**更新时间**: 2026-01-19  
**版本**: v4.0  
**状态**: 已优化超时机制
