# 拖拽事件时间格式问题修复

## 问题描述

拖拽重复事件实例后，数据库中的时间格式不一致：

### 修复前
```json
// 原始事件
"start": "2025-10-14T19:00:00"  // 本地时间格式

// 拖拽后
"start": "2025-10-14T10:00:00.000Z"  // UTC时间格式（带.000Z后缀）
```

### 问题根源

1. **前端发送**: `event.start.toISOString()` 生成 UTC 时间 `2025-10-14T10:00:00.000Z`
2. **后端接收**: 直接使用 `new_start` 参数，没有转换格式
3. **数据不一致**: 数据库中混合了本地时间和UTC时间两种格式

## 时间转换逻辑

### 数据库存储标准
所有事件时间应以**本地时间**格式存储：`%Y-%m-%dT%H:%M:%S`

例如: `2025-10-14T19:00:00`

### 前后端时间流转

```
前端 FullCalendar
  ↓ toISOString()
UTC时间: 2025-10-14T10:00:00.000Z (北京时间18:00对应UTC 10:00)
  ↓ 发送到后端
后端接收
  ↓ 转换
本地时间: 2025-10-14T18:00:00
  ↓ 保存到数据库
```

### 时区说明
- **北京时间 = UTC+8**
- `2025-10-14T18:00:00` (本地) = `2025-10-14T10:00:00Z` (UTC)
- 你的数据显示: `19:00:00` (本地) → `10:00:00.000Z` (UTC)，相差9小时？

**注意**: 你的数据显示相差9小时，可能是 `convert_time_format` 函数有问题：
```python
local_time = utc_time - timedelta(hours=-8)  # 这里是 -(-8) = +8，应该改为 +8
```

## 修复方案

### 1. 修改 `update_events_impl` - single 模式

```python
# 5. 创建独立的例外事件（在新时间）
# 将UTC时间转换为本地时间格式（如果需要）
formatted_start = new_start
formatted_end = new_end
if new_start and new_start.endswith('Z'):
    utc_time = datetime.datetime.fromisoformat(new_start.replace('Z', '+00:00'))
    local_time = utc_time + timedelta(hours=8)  # UTC+8 = 北京时间
    formatted_start = local_time.strftime('%Y-%m-%dT%H:%M:%S')
if new_end and new_end.endswith('Z'):
    utc_time = datetime.datetime.fromisoformat(new_end.replace('Z', '+00:00'))
    local_time = utc_time + timedelta(hours=8)
    formatted_end = local_time.strftime('%Y-%m-%dT%H:%M:%S')

updated_event.update({
    'start': formatted_start,  # 使用转换后的时间
    'end': formatted_end,
    # ...
})
```

### 2. 修改单次事件处理

同样的逻辑应用到非重复事件的更新：

```python
else:
    # 单次事件的处理
    # 将UTC时间转换为本地时间格式（如果需要）
    formatted_start = new_start
    formatted_end = new_end
    if new_start and new_start.endswith('Z'):
        utc_time = datetime.datetime.fromisoformat(new_start.replace('Z', '+00:00'))
        local_time = utc_time + timedelta(hours=8)
        formatted_start = local_time.strftime('%Y-%m-%dT%H:%M:%S')
    # ...
```

## 修复后的数据格式

### 期望的数据库记录
```json
{
  "id": "fec13888-5f78-44cd-bcc9-b62edfbcaf4a",
  "title": "测试拖拽",
  "start": "2025-10-14T18:00:00",  // 本地时间，无.000Z后缀
  "end": "2025-10-14T19:00:00",
  "series_id": "",                  // 已从系列独立
  "is_recurring": false,
  "is_exception": true,             // 标记为例外
  "original_series_id": "29caec15-...",  // 记录原系列
  "original_start": "2025-10-14T19:00:00", // 记录原始时间
  "rrule": ""
}
```

## 关于 is_exception 字段

虽然代码中设置了 `'is_exception': True`，但你的数据中没显示。可能原因：

1. **UserData 的 JSON 存储**: 所有字段都会保存，只是你查看时可能被省略了
2. **不影响功能**: 即使不显示，只要保存了就能正常工作
3. **验证方法**: 可以在数据库中完整查看 UserData 的 value 字段

## convert_time_format 函数问题

**注意**: 原代码中的时区转换可能有误：

```python
def convert_time_format(events):
    for event in events:
        for key in ['start', 'end']:
            if event[key].endswith('Z'):
                utc_time = datetime.datetime.fromisoformat(event[key].replace('Z', '+00:00'))
                local_time = utc_time - timedelta(hours=-8)  # ❌ 这里是 +8 小时
                event[key] = local_time.strftime('%Y-%m-%dT%H:%M')
    return events
```

**应该改为**:
```python
local_time = utc_time + timedelta(hours=8)  # ✅ UTC+8 = 北京时间
```

或者:
```python
local_time = utc_time.replace(tzinfo=timezone.utc).astimezone(timezone(timedelta(hours=8)))
```

## 测试验证

1. **清空旧数据**: 删除之前格式错误的测试事件
2. **创建新事件**: 创建每日重复的测试事件
3. **拖拽测试**: 拖拽一个实例到新时间
4. **检查数据库**:
   - `start` 和 `end` 应该是 `%Y-%m-%dT%H:%M:%S` 格式
   - 没有 `.000Z` 后缀
   - 时间是北京时间（非UTC）
5. **检查功能**: 日历显示的时间应该正确

## 总结

### 修改文件
- `core/views_events.py`: 
  - 第2110-2122行: single 模式的时间格式转换
  - 第2236-2248行: 单次事件的时间格式转换

### 核心原则
所有保存到数据库的时间都应该：
1. **格式**: `%Y-%m-%dT%H:%M:%S`（不带毫秒和时区）
2. **时区**: 北京时间（UTC+8）
3. **一致性**: 所有事件使用相同格式

### 注意事项
如果发现时间仍然不对，请检查 `convert_time_format` 函数的时区计算！
