# 拖拽重复事件自动补全问题修复说明

## 问题描述
在通过拖拽修改重复事件实例时间时,虽然弹出了确认对话框并成功将实例独立出去,但原位置仍然会自动补全一个新的日程实例。

## 根本原因
当使用 `rrule_change_scope='single'` 模式编辑重复事件实例时:

1. **旧逻辑**:
   - 将被拖拽的实例独立出去(设置 `series_id=None`, `is_recurring=False`)
   - 创建一个"替换事件"放在原位置(保留 `series_id` 和 `is_recurring=True`)
   - 问题: 替换事件仍然是重复事件,所以自动生成逻辑会继续补全

2. **核心缺陷**: 没有给原系列的 RRule 添加 **EXDATE**(例外日期)

## RRule 的 EXDATE 机制
在 iCalendar 规范中,EXDATE 用于排除重复规则中的特定日期:

```
RRULE:FREQ=DAILY;INTERVAL=1;EXDATE=20251014T180000
```

这表示每天重复,但 2025-10-14 18:00:00 这个日期被排除,不会自动生成实例。

## 正确的 Single 模式编辑逻辑

参考 `delete_event_impl` 中删除单个实例的处理方式(1400-1450行):

```python
if edit_scope == 'single':
    # 1. 找到目标事件的时间
    target_event_time = datetime.datetime.fromisoformat(event['start'])
    
    # 2. 添加EXDATE例外
    manager.rrule_engine.delete_instance(series_id, target_event_time)
    
    # 3. 获取更新后的系列信息(包含EXDATE)
    updated_series = manager.rrule_engine.get_series(series_id)
    segments_data = updated_series.get_segments_data()
    
    # 4. 重新构建rrule字符串,包含EXDATE
    main_segment = segments_data[0]
    updated_rrule = main_segment['rrule_str']
    
    if main_segment.get('exdates'):
        exdate_strs = [exdate.strftime('%Y%m%dT%H%M%S') for exdate in main_segment['exdates']]
        updated_rrule += ';EXDATE=' + ','.join(exdate_strs)
    
    # 5. 更新所有同系列事件的rrule字段
    for event in events:
        if event.get('series_id') == series_id:
            event['rrule'] = updated_rrule
```

## 修复方案

### 修改文件: `core/views_events.py` 的 `update_events_impl` 函数

在 `rrule_change_scope == 'single'` 分支中:

1. **添加 EXDATE 到原系列** (第2067-2104行):
   - 获取原始事件时间
   - 调用 `manager.rrule_engine.delete_instance(series_id, target_event_time)`
   - 获取更新后的 RRule Series
   - 重建包含 EXDATE 的 rrule 字符串
   - 更新所有同系列事件的 rrule 字段

2. **创建独立的例外事件** (第2106-2127行):
   - 设置 `series_id=None`, `is_recurring=False`
   - 设置 `is_exception=True`, 保存 `original_series_id`

3. **移除替换事件的创建逻辑**:
   - 因为添加了 EXDATE,原位置不会再自动生成
   - 不需要创建"替换事件"

## 关键代码变更

```python
# 2. 添加EXDATE例外到原系列
if target_event_time and series_id:
    manager.rrule_engine.delete_instance(series_id, target_event_time)
    logger.info(f"Added EXDATE for series {series_id} at {target_event_time}")
    
    # 3. 获取更新后的系列信息，包含EXDATE
    updated_series = manager.rrule_engine.get_series(series_id)
    if updated_series:
        segments_data = updated_series.get_segments_data()
        if segments_data:
            main_segment = segments_data[0]
            updated_rrule = main_segment['rrule_str']
            
            # 添加EXDATE信息
            if main_segment.get('exdates'):
                exdate_strs = []
                for exdate in main_segment['exdates']:
                    if isinstance(exdate, str):
                        exdate_strs.append(exdate)
                    else:
                        exdate_strs.append(exdate.strftime('%Y%m%dT%H%M%S'))
                if exdate_strs:
                    updated_rrule += ';EXDATE=' + ','.join(exdate_strs)
            
            # 4. 更新events数组中所有同系列事件的rrule字段
            for event in events:
                if event.get('series_id') == series_id:
                    event['rrule'] = updated_rrule
                    event['last_modified'] = last_modified
```

## 测试验证

1. 创建一个每日重复的测试事件
2. 拖拽某个实例到新时间
3. 确认对话框选择"确定"
4. 验证:
   - 被拖拽的实例移动到新时间,成为独立事件
   - 原位置**不再自动生成**新实例
   - 系列的其他实例正常显示

## 数据库变化对比

### 修复前
- 被拖拽事件: `series_id=null, is_recurring=false` ✅
- 自动补全事件: `series_id=xxx, is_recurring=true, rrule=FREQ=DAILY` ❌ (问题!)

### 修复后
- 被拖拽事件: `series_id=null, is_recurring=false, is_exception=true` ✅
- 系列主事件: `rrule=FREQ=DAILY;EXDATE=20251014T180000` ✅
- 无自动补全事件 ✅

## 总结

**核心要点**: Single 模式编辑重复事件实例时,必须同时:
1. 给原系列添加 EXDATE,阻止自动生成
2. 将实例独立出去,创建例外事件

这与删除单个实例的逻辑完全一致,只是删除时不创建新事件,而编辑时要在新位置创建独立事件。

## 相关代码引用

- `rrule_engine.py`: `RRuleSeries.add_exception()` (第83行)
- `views_events.py`: `delete_event_impl` 的 single 模式处理 (第1400-1450行)
- `views_events.py`: `update_events_impl` 的 single 模式处理 (第2063-2133行)
